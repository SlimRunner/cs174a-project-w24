<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body style="white-space: pre-wrap;">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body style="white-space: pre-wrap;">
class Shape

Shape explains to the GPU the layout of one type of 3D shape. Shape objects organize all data related to one shape,
along with managing a copy in GPU memory. Data is broken down per-vertex of the shape. Think of vertices as the corner
points of your shape, but in addition to storing a position, they could store additional data per vertex as needed. To
use a Shape, fill in the "arrays" property, within which you design all the fields that you can look up in a vertex. For
each field, a whole array will be made here of that data type, indexed per vertex. Along with your fields is an
additional array "indices" describing how vertices are grouped with each other into shape primitives. A triple of vertex
indices makes one triangle, for example. If you omit an indices array, then your elements in "arrays" will be
automatically be grouped into primitives, in the order they're listed in. The default is groups of three.

constructor (...array_names)

When creating any Shape, you must first tell it which per-vertex fields you intend to use. Argument array_names contains
the desired names of your fields. Empty arrays will then be made for you.

copy_onto_graphics_card (context, selection_of_arrays = Object.keys (this.arrays), write_to_indices = true)

Called automatically as needed to load the vertex arrays of this Shape onto one of your GPU contexts for its first time.
The goal is to send the completed vertex and index lists to their own buffers within any of your existing graphics card
contexts. Optional arguments allow the user to manually call copy_onto_graphics_card again to overwrite the GPU buffers
related to this shape's arrays, or overwrite subsets of them as needed (if only some fields of your shape have changed).

execute_shaders (gl, gpu_instance, type)

Draws this shape, by converting its entire vertex buffer into an image onscreen. This function contains the WebGL call
that launches the two shader programs. Draw shapes using indices if they exist. Otherwise, assume the vertices are
arranged in the order they should be grouped into.

draw (webgl_manager, uniforms, model_transform, material, type = "TRIANGLES")

To appear onscreen, a shape of any variety goes through this function. It makes a call to Shape::execute_shaders(). The
shaders draw the right shape because of a setup step taken here: pre-selection of the correct buffer region in the GPU
that holds that shape's data.

******
NOTE: All the below functions make a further assumption: that your vertex buffer includes fields called "position" and
"normal" stored at each point, instead of just any arbitrary fields. Each vertex will have a 3D position and a 3D normal
vector as available fields within "arrays" (both of type Vector3).

Warning: Your arrays must be full! The below functions will FAIL if you leave so much as a single element of your arrays
empty. Likewise, if your "indices" references any elements that aren't filled in, your shape won't draw on the GPU.

static insert_transformed_copy_into (recipient, args, points_transform = Mat4.identity ())

Builds compound shapes, which are Shapes with array contents combined out of smaller shapes' arrays. A copy of this
shape is made (using the given args) and inserted into any recipient shape you pass in. Compound shapes help reduce draw
calls and speed up performance. One shape joins the other at a custom transform offset "points_transform", adjusting
positions and normals appropriately.

make_flat_shaded_version ()

make_flat_shaded_version(): Auto-generate a new class that re-uses any Shape's points, but with new normals -- generated
from flat shading. A way to compute normals from scratch for shapes that have none.

duplicate_the_shared_vertices ()

duplicate_the_shared_vertices(): Eliminate inter-triangle sharing of vertices. Doing so is necessary for any points
that hold data that we want to abruptly vary as we cross over a triangle edge. Examples include texture images that
abruptly change over an edge, or abrupt normal vector changes that create the appearance of a hard edge with no
blending. Modify an indexed shape to remove any edges where the same vertices are indexed by both the adjacent
triangles. The two triangles otherwise fight over assigning their differing data values to the shared vertices.

flat_shade ()

flat_shade(): Automatically assign the correct normals to each triangular element to achieve flat shading. Assumes that
no vertices are shared across seams. Internal helper function.

const Shader

See the lesson called "Shaders".

Shader loads a GLSL shader program onto your graphics card, starting from a JavaScript string. To use, make subclasses
of Shader that override special functions that define these strings of GLSL code. The base class will command the GPU to
receive, compile, and run these programs. In WebGL 1, the shader runs once per every shape that is drawn onscreen.

Extend the class and fill in the abstract functions, some of which define GLSL strings, and others (update_GPU) which
define the extra custom JavaScript code needed to populate the GPU's memory with all the data values your particular
shader program is expecting, such as matrices. The shader pulls these values from two JavaScript objects: "material" for
values pertaining to the current shape only, and "uniforms" for values pertaining to the whole scene at a given moment.

copy_onto_graphics_card (context)

Called automatically as needed to load the shader program onto one of your GPU contexts for its first time. Once we
move it there, the GPU compiles the shader program using our strings.

NOTE: Class Graphics_Addresses is a helper inner class found here, used internally in Shaders for organizing
communication with the GPU. Once we've compiled the Shader, we can query some things about the compiled program, such as
the memory addresses it will use for uniform variables, and the types and indices of its per-vertex attributes. We'll
need those for building vertex buffers.

activate (context, buffer_pointers, uniforms, model_transform, material)

Selects this Shader in GPU memory so the next shape draws using it.

static assign_camera (camera_inverse, uniforms)

Camera matrices and their inverses should be cached together, in sync, since both are frequently needed, and to limit
slow calls to Mat4::inverse().

******
NOTE: Override the following:

vertex_glsl_code ()

You must override this function to make a Shader; does nothing by default. Returns a string containing GLSL code for
a custom vertex shader. See the lesson called "Vertex Shaders".

fragment_glsl_code ()

You must override this function to make a Shader; does nothing by default. Returns a string containing GLSL code for
a custom fragment shader. See the lesson called "Fragment Shaders".

update_GPU ()

You must override this function to make a Shader; does nothing by default. Include the extra custom JavaScript code
needed to populate the GPU's memory with all the data values your particular shader program is expecting, such as
matrices.


class Texture

Texture manages a 2D image on the GPU that can color (or exert other influence) along a shape's surface. A new HTML
image object stores the image. A Texture object copies the image to the GPU buffers as needed. It wraps a pointer to
where it is stored in GPU memory, for referencing it later. Optionally, mip maps can be generated when the texture is
created. too.

constructor (filename, min_filter = "LINEAR_MIPMAP_LINEAR")

Change min_filter to other WebGL settings to change the minification method, which is visible whenever the per-pixel
screen samples appear larger than the per-image texture samples. By default, mip mapping is used for blending.

copy_onto_graphics_card()

Called automatically as needed to load the texture image onto one of your GPU contexts for its first time.

activate()

Selects this Texture in GPU memory so the next shape draws using it. Optionally select a texture unit in case you're
using a shader with many sampler variables.

class Component

See the lesson called "Component".

To use Component, override certain methods. To draw a 3D scene, override render_animation and call draw() on existing
Shapes.

constructor (props = {})

Use the "props" argument to pass certain custom settings to a Component. For example, if it is sharing its "uniforms"
collection with another Component, you would pass in the shared value through props.

Component.uniforms

The member "uniforms" builds a group of variables meant to become shader uniforms. This is a non-standard solution that
works for WebGL 1. Uniforms objects may be shared across scenes in a canvas, or even across canvases, to sync their
contents.

make_context (canvas, background_color = color (0, 0, 0, 1), dimensions)

For Components hosting their own canvas in their document area, prepare a region of GPU memory to hold a new graphics
context for it.

set_canvas_size (dimensions = [1080, 600])

Re-sizes the canvas anytime.

frame_advance (time = 0)

Draw a single frame of animation, including all child Component objects. Measure how much real time has transpired in
order to animate movement accordingly.

new_line (parent = this.control_panel)

Formats a scene's control panel area with a new line break.

live_string (callback, parent = this.control_panel)

Create an element somewhere in the control panel area that does reporting of the scene's values in real time. The event
loop will constantly update all HTML elements made this way. Slow and not ideal; React-js does it better.

key_triggered_button (description, shortcut_combination, callback,
color = '#' + Math.random ().toString (9).slice (-6),
release_event, recipient = this,
parent = this.control_panel)

Create an interactive button for affecting the Component visible on the its own control panel area. Label the HTML
button using "description". Trigger any Component behavior from the button by assigning a key shortcut
"shortcut_combination" to fire any callback function/method "callback". Assign button HTML hex color via "color", which
defaults to a random hex color. Optional release callback "release_event" as well. Event recipient and UI capture
area can be configured as well, useful for some applications.


init () {}

You must override this function to make a Component; does nothing by default. Use init() to create initial values for
your Component.

WARNING: ALL Shape, Shader, and Texture declarations should go inside of init(). To declare them elsewhere will result
in serious damage to performance, since these objects are not meant to be transmitted to the GPU more than once
(remember that render_animation is called every frame!). If a failure to heed this is detected, an error message
results.

To use class Scene, override init() as well as at least one of the below 4 functions, which will be automatically
called by other classes:

render_layout (div, options = {})
render_animation (context) {}
render_documentation () {}
render_controls () {}

See lesson called "Component" for their descriptions. Consult the included demos for examples on how to make your
own implementations.

Note that render_layout() comes with a default implementation. By default, it sets up a reasonable HTML document with a
canvas drawing area, making use of the tools in tiny-graphics-gui.js.
</body>
</html>
