<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body style="white-space: pre-wrap;">
Vector and Matrix algebra are not built into JavaScript at first. We will add it now. Our file is broken down into two
parts: Vectors, then Matrices.

# Part I: Vectors: *************************************************************************************

You will be able to declare a 3D vector [x,y,z] supporting various common vector operations with syntax: vec(x,y), vec3(
x,y,z ) or vec4( x,y,z, zero or one ). For general sized (larger) vectors, use class Vector and declare them with
standard Array-supported operations.

To create vector algebra tools that performs well in JavaScript, we based class Vector on consecutive buffers (using
types Float32Array). Classes Vector3 and Vector4 are similar to Vector. Shorthand functions for creating them are,
respectively, vec3(), vec4(), and vec(). Implementations should specialize for common vector sizes 3 and 4, since
JavaScript engines can better optimize functions when they can predict argument count. Implementations should also avoid
allocating new array objects when possible, since these will all have to be garbage collected.

## How to use, with examples:

** For vector size 3 **

equals: "vec3( 1,0,0 ).equals( vec3( 1,0,0 ) )" returns true.
plus: "vec3( 1,0,0 ).plus ( vec3( 1,0,0 ) )" returns the Vector3 [ 2,0,0 ].
minus: "vec3( 1,0,0 ).minus ( vec3( 1,0,0 ) )" returns the Vector3 [ 0,0,0 ].
mult-pairs: "vec3( 1,2,3 ).mult_pairs( vec3( 3,2,0 ) )" returns the Vector3 [ 3,4,0 ].
scale: "vec3( 1,2,3 ).scale( 2 )" overwrites the Vector3 with [ 2,4,6 ].
times: "vec3( 1,2,3 ).times( 2 )" returns the Vector3 [ 2,4,6 ].
randomized: Returns this Vector3 plus a random Vector3 of a given maximum vector length.
mix: "vec3( 0,2,4 ).mix( vec3( 10,10,10 ), .5 )" returns the Vector3 [ 5,6,7 ].
norm: "vec3( 1,2,3 ).norm()" returns the square root of 15.
normalized: "vec3( 4,4,4 ).normalized()" returns the Vector3 [ sqrt(3), sqrt(3), sqrt(3) ]
normalize: "vec3( 4,4,4 ).normalize()" overwrites the Vector3 with [ sqrt(3), sqrt(3), sqrt(3) ].
dot: "vec3( 1,2,3 ).dot( vec3( 1,2,3 ) )" returns 15.
cast: "vec3.cast( [-1,-1,0], [1,-1,0], [-1,1,0] )" converts the type of all elements passed in from Array to Vector3.
to4: "vec3( 1,2,3 ).to4( true or false )" returns the homogeneous Vector4 [ 1,2,3, 1 or 0 ].
cross: "vec3( 1,0,0 ).cross( vec3( 0,1,0 ) )" returns the Vector3 [ 0,0,1 ]. Use only on 3x1 Vecs.
to_string: "vec3( 1,2,3 ).to_string()" returns the string "[vec3 1, 2, 3]"

** Vector size 4 operations are similar to the above, except for: **
to3: "vec4( 4,3,2,1 ).to3()" returns the the Vector3 containing [ 4,3,2 ]. Use to truncate Vector4 to Vector3.

** To assign by value **
copy: "let new_vector = old_vector.copy()" assigns by value so you get a different vector object.

WARNING: Code like the following can have surprising results! Use copy() instead.
let vector_1 = vec3( 1,2,3 );
let vector_2 = vector_1;
vector_2.scale( 2 ); // vector_1 no longer equals [ 1,2,3 ]!

** For any size **
to declare: Vector.of( 1,2,3,4,5,6,7,8,9,10 ) returns a Vector filled with those ten entries.

** For multiplication by matrices **
"any_mat4.times( vec4( 1,2,3,0 ) )" pre-multiplies the homogeneous vector [ 1,2,3,0 ]
by the 4x4 matrix and returns the new Vector4. Requires a Vector4 as input.

# Vector

class Vector extends Float32Array

**Vector** stores vectors of floating point numbers. Puts vector math into JavaScript. Note: Vectors should be
created with of() due to weirdness with the TypedArray spec. Tip: Assign Vectors
with .copy() to avoid referring two variables to the same Vector object.


In-fix operations: Use these for more readable math expressions.
equals( b )
plus( b )
minus( b )
times( s )
times_pairwise( b )

Pre-fix operations: Use these for better performance (to avoid new allocation).
add_by( b )
subtract_by( b )
scale_by( s )
scale_pairwise_by( b )

Other operations:

randomized( s )
mix( b, s )
norm()
normalized()
normalize()
dot( b )
cross( b )
copy()
static cast( ...args )

See the above examples for descriptions of each function. Additional notes follow:

Class Vector implements all functions of Vector3 and Vector4, even including the following:

to3()
to4( is_a_point )
cross(b)

This is done in order to standardize the API, so the performance hit of changing between these types can be measured.

static create (...arr)

This function prevents us from having to type extra square brackets, such as in code like this:

new Vector( [ 5,6,7 ]);

Because we are using JavaScript's faster TypedArrays, normally they require the square brackets during
initialization. However, by calling create, we can omit them:

Vector.create( 5,6,7 );

Shorthand for Vector::create exists in the library:

vec( 5,6,7 );

static cast( ...args )

Use cast() when you want more compact syntax when declaring long lists of Vectors. You can simply use JavaScript's
array literal syntax (square brackets, elements separated by commas) to declare many elements, then convert with cast().

# Vector3

class Vector3 extends Float32Array

Vector3 is a specialization of Vector only for size 3, for performance reasons.

static create( x, y, z )

See above description of the general-sized Vector's method create(). In addition, shorthand for Vector3::create exists
in the library:

vec3( 5,6,7 );

static copy()

Assigns a Vector3 by value. Always make sure to use this for copying vector values! See the warning in examples above.

static cast(...args)

Converts the type of all elements passed in from Array to Vector3.

static unsafe( x,y,z )

Returns vec3s only meant to be consumed immediately. Aliases into shared memory, to be overwritten upon next
unsafe3 call. Faster. Do not use these to generate any Vector3 variable you intend to keep. They are only for
holding intermediate values in calculations.

to4( is_a_point )

Convert to a homogeneous vector of 4 values.

# Vector4

class Vector4 extends Float32Array

Vector4 is a specialization of Vector only for size 4, for performance reasons. The fourth coordinate value is
homogenized (0 for a vector, 1 for a point).

Same functions as Vector3 except for:

static create( x, y, z, w )

See above description of the general-sized Vector's method create(). In addition, shorthand for Vector3::create exists
in the library:

vec4( 5,6,7,1 );

static unsafe( x,y,z, w )

unsafe(): returns vec4s only meant to be consumed immediately. Aliases into shared memory, to be overwritten upon next
unsafe4 call. Faster. Do not use these to generate any Vector4 variable you intend to keep. They are only for
holding intermediate values in calculations.

to3()

Returns a Vector3 obtained by dropping the fourth coordinate value from this Vector4.


# Shorthand

Other aliases for Vectors:

math.vec = Vector .create;
math.vec3 = Vector3.create;
math.vec4 = Vector4.create;
math.unsafe3 = Vector3.unsafe;
math.unsafe4 = Vector4.unsafe;
math.color = Vector4.create;

Color

math.color is just an alias for class Vector4. Colors should be made as special 4x1 vectors expressed as ( red, green,
blue, opacity ) each ranging from 0 to 1.


# Part II: Matrices: *************************************************************************************

For matrices, you will use class Mat4 to generate the 4 by 4 matrices that are common in graphics. For general sized
matrices you can use class Matrix.

# Matrix

class Matrix extends Array

Matrix holds M by N matrices of floats. This class enables matrix and vector math.

Example usage:

"Matrix( rows )" (where rows is an array of float arrays) returns a Matrix with those rows.
"M.set_identity( m, n )" assigns the m by n identity to Matrix M.
"M.sub_block( start, end )" where start and end are each a [ row, column ] pair returns a sub-rectangle cut out from M.
"M.copy()" creates a deep copy of M and returns it so you can modify it without affecting the original.
"M.equals(b)", "M.plus(b)", and "M.minus(b)" are operations betwen two matrices.
"M.transposed()" returns a new matrix where all rows of M became columns and vice versa.
"M.times(b)" (where the post-multiplied b can be a scalar, a Vector4, or another Matrix) returns a
new Matrix or Vector4 holding the product.
"M.pre_multiply(b)" overwrites the Matrix M with the product of b * M where b must be another Matrix.
"M.post_multiply(b)" overwrites the Matrix M with the product of M * b where b can be a Matrix or scalar.
"Matrix.flatten_2D_to_1D( M )" flattens input (a Matrix or any array of Vectors or float arrays)
into a row-major 1D array of raw floats.
"M.to_string()" where M contains the 4x4 identity returns the string "[[1, 0, 0, 0] [0, 1, 0, 0] [0, 0, 1, 0] [0, 0, 0,
1]]".

constructor( ...args )

Builds a Matrix out of the supplied rows. Pass in multiple arrays of floats.

set( M )

Assigns the value of Matrix M to this Matrix.

set_identity ( m, n )

Expands this matrix to size m by n if necessary, then fills in all elements with 0's, except for 1's along the diagonal.

sub_block( start, end )

Returns a sub-rectangle cut out from M. Both arguments, start and finish, expect a [ row, column ] pair of indices.
Example to return the upper 3x3 square of a matrix:
sub_block([ [ 0,3 ], [ 0,3 ] ])

copy ()

Assigns by value so you get a different Matrix object, like this:

let new_matrix = old_matrix.copy()

WARNING: Code like the following can have surprising results! Use copy() instead.
let matrix_1 = Mat4.identity();
let matrix_2 = matrix_1;
matrix_2.post_multiply( Mat4.scale( 2,2,2 ) ); // matrix_1 no longer equals the identity matrix!

equals (b)
plus (b)
minus (b)

Given this Matrix and another Matrix b, these three functions do pair-wise comparisons or arithmetic of each of the
elements in the two matrices.

transposed()

Returns a Matrix with all elements in transposed positions. Does not modify the original Matrix.

times (b, optional_preallocated_result)

Given this Matrix and another Matrix b, returns the matrix product when post-multiplying b. Does not modify the
original Matrix. Calls to times() can be chained together like this:

let result = A.times( B ).times( C ).times( D );

You can speed up the times() function by using the optional argument optional_preallocated_result to provide a temporary
Matrix of the same size as the expected product. The passed in matrix will be used to store the result instead of
allocating memory for a new Matrix.

pre_multiply (b)

Unlike times(), pre_multiply modifies the original Matrix (this). Given another Matrix b, overwrites this Matrix with
b*this, and returns the new result.

post_multiply(b)

Unlike times(), post_multiply modifies the original Matrix (this). Given another Matrix b, overwrites this Matrix with
this*b, and returns the new result.

static flatten_2D_to_1D( M )

Collapses this Array of Float32Arrays, resulting in a single 1D Float32Array. Returns a new Float32Array containing all
the rows of this Matrix joined together. This static function is useful even outside class Matrix, for the general case
of wanting to combine multiple Float32Arrays into a single larger one.

to_string()

Returns a human-readable form of this matrix, in comma-separated notation (like JSON), for your convenience when
debugging.

# Mat4

class Mat4 extends Matrix

Generates special 4x4 matrices that are useful for graphics. All the methods below return a certain 4x4 matrix.

static identity()

Returns a new 4 x 4 identity matrix.

static rotation( angle, x,y,z )

Returns a 3D rotation as a new 4x4 matrix. Requires a scalar (angle) and a three-component axis vector. The coordinate
space rotates around the supplied vector (not necessarily aligned with an axis) by "angle" radians.

static scale( x,y,z )

Returns a new 4x4 matrix representing a scaling of the coordinate axes. Pass in scale factors (floats) for each of
the x, y, and z axes.

static translation( x,y,z )

Returns a new 4x4 matrix representing a translation of the coordinate axes. Pass in desired x, y, and z movement.

static look_at( eye, at, up )

Produce a traditional graphics camera "lookat" matrix. Each input must be a 3x1 Vector. Given two endpoints (eye
and at), generates a camera matrix looking exactly at the "at" point. There is still one degree of freedom left to
specify: The camera's roll vector. You must provide an "up" vector to fully define that. Even if "up" is not exactly
perpendicular to the line between our endpoints (eye-at), the closest perpendicular vector to your supplied "up" will be
used to roll the camera upright.

Note: As per tradition in graphics, look_at() assumes the result will be used for a camera and therefore stores its
result in inverse space, where all cameras live. If you want to INSTEAD use look_at to point a non-camera (a visible
object) towards something, you can do so, but to generate the correct basis you must re-invert the returned matrix.

static orthographic( left, right, bottom, top, near, far )

Returns a new 4x4 matrix for projection. Defines a box-shaped view volume. Collapses the specified view volume into
the normalized view volume, as the graphics pipeline expects.

static perspective( fov_y, aspect, near, far )

Returns a new 4x4 matrix for projection. Defines an expanding frustum-shaped view volume, which allows perspective
and vanishing point effects. Collapses the specified view volume into the normalized view volume, as the graphics
pipeline expects.

static inverse( m )

Returns a new Mat4 containing the 4x4 inverse of this one. Computing it is slow because of the sheer amount of
arithmetic steps visible below; call inverse() fewer times when possible.  Cache the result of calling inverse()
(save it somewhere) whenever it is expected to stay the same the next time you need it.


</body>
</html>
